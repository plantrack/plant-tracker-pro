services:
  - type: web
    name: plant-tracker-pro-demo
    runtime: node
    repo: https://github.com/render-examples/express-hello-world
    buildCommand: |
      # Install dependencies
      npm init -y
      npm install express better-sqlite3 multer cors bcryptjs jsonwebtoken googleapis
      
      # Create the server file
      cat > server.js << 'EOF'
      const express = require('express');
      const Database = require('better-sqlite3');
      const multer = require('multer');
      const path = require('path');
      const fs = require('fs');
      const cors = require('cors');
      const bcrypt = require('bcryptjs');
      const jwt = require('jsonwebtoken');
      
      const app = express();
      const PORT = process.env.PORT || 3000;
      const JWT_SECRET = process.env.JWT_SECRET || 'plant-tracker-secret-key-2024';
      
      app.use(cors({ origin: '*', credentials: true }));
      app.use(express.json());
      app.use('/uploads', express.static('uploads'));
      
      ['uploads', 'uploads/thumbnails'].forEach(dir => {
        if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
      });
      
      const storage = multer.diskStorage({
        destination: (req, file, cb) => cb(null, 'uploads/'),
        filename: (req, file, cb) => cb(null, Date.now() + '_' + file.originalname.replace(/\s/g, '_'))
      });
      
      const upload = multer({ storage, limits: { fileSize: 50 * 1024 * 1024 } });
      const db = new Database('./plants.db');
      
      // Create tables
      db.exec(`
        CREATE TABLE IF NOT EXISTS users (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          username TEXT UNIQUE NOT NULL,
          email TEXT UNIQUE NOT NULL,
          password TEXT NOT NULL,
          farm_name TEXT,
          spreadsheet_id TEXT,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );
        CREATE TABLE IF NOT EXISTS fields (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          user_id INTEGER NOT NULL,
          name TEXT NOT NULL,
          size_acres REAL,
          crop_type TEXT,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          FOREIGN KEY (user_id) REFERENCES users(id)
        );
        CREATE TABLE IF NOT EXISTS plants (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          user_id INTEGER NOT NULL,
          field_id INTEGER,
          location_id TEXT NOT NULL,
          latitude REAL NOT NULL,
          longitude REAL NOT NULL,
          timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
          photo_path TEXT,
          notes TEXT,
          plant_type TEXT,
          growth_stage TEXT,
          height_cm REAL,
          health_score INTEGER,
          synced_to_sheets BOOLEAN DEFAULT 0,
          FOREIGN KEY (user_id) REFERENCES users(id),
          FOREIGN KEY (field_id) REFERENCES fields(id)
        );
      `);
      
      // Create demo user
      const insertDemo = db.prepare(`INSERT OR IGNORE INTO users (username, email, password, farm_name, spreadsheet_id) VALUES (?, ?, ?, ?, ?)`);
      insertDemo.run('demo', 'demo@planttracker.com', '$2a$10$EkgIbzusalAjNsFdUGCMCOawbqq1xpSHy.C4CtTeL2AjVw47v04eO', 'Demo Farm', 'not_configured');
      
      const authenticateToken = (req, res, next) => {
        const authHeader = req.headers['authorization'];
        const token = authHeader && authHeader.split(' ')[1];
        if (!token) return res.status(401).json({ error: 'Access token required' });
        jwt.verify(token, JWT_SECRET, (err, user) => {
          if (err) return res.status(403).json({ error: 'Invalid token' });
          req.user = user;
          next();
        });
      };
      
      app.get('/', (req, res) => {
        res.json({ 
          status: 'Plant Tracker API Running',
          demo: { username: 'demo', password: 'demo123' }
        });
      });
      
      app.get('/health', (req, res) => res.json({ status: 'healthy' }));
      
      app.post('/api/auth/login', async (req, res) => {
        const { username, password } = req.body;
        const user = db.prepare(`SELECT * FROM users WHERE username = ? OR email = ?`).get(username, username);
        if (!user || !await bcrypt.compare(password, user.password)) {
          return res.status(401).json({ error: 'Invalid credentials' });
        }
        const token = jwt.sign({ id: user.id, username: user.username, email: user.email }, JWT_SECRET, { expiresIn: '30d' });
        res.json({ token, user: { id: user.id, username: user.username, email: user.email, farm_name: user.farm_name } });
      });
      
      app.post('/api/auth/register', async (req, res) => {
        const { username, email, password, farm_name } = req.body;
        try {
          const hashedPassword = await bcrypt.hash(password, 10);
          const result = db.prepare(`INSERT INTO users (username, email, password, farm_name, spreadsheet_id) VALUES (?, ?, ?, ?, ?)`).run(username, email, hashedPassword, farm_name || '', 'not_configured');
          const token = jwt.sign({ id: result.lastInsertRowid, username, email }, JWT_SECRET, { expiresIn: '30d' });
          res.json({ token, user: { id: result.lastInsertRowid, username, email, farm_name } });
        } catch (err) {
          res.status(400).json({ error: 'Username or email already exists' });
        }
      });
      
      app.post('/api/plants', authenticateToken, upload.single('photo'), async (req, res) => {
        const { latitude, longitude, notes, plant_type, growth_stage, field_id, height_cm, health_score } = req.body;
        const photo_path = req.file ? `/uploads/${req.file.filename}` : null;
        const location_id = `${parseFloat(latitude).toFixed(6)}_${parseFloat(longitude).toFixed(6)}`;
        const result = db.prepare(`INSERT INTO plants (user_id, field_id, location_id, latitude, longitude, photo_path, notes, plant_type, growth_stage, height_cm, health_score) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`).run(req.user.id, field_id || null, location_id, latitude, longitude, photo_path, notes || '', plant_type || '', growth_stage || '', height_cm || null, health_score || null);
        res.json({ id: result.lastInsertRowid, location_id, message: 'Plant record created successfully' });
      });
      
      app.get('/api/plants', authenticateToken, (req, res) => {
        const rows = db.prepare(`SELECT * FROM plants WHERE user_id = ? ORDER BY timestamp DESC`).all(req.user.id);
        res.json(rows);
      });
      
      app.get('/api/fields', authenticateToken, (req, res) => {
        const rows = db.prepare(`SELECT * FROM fields WHERE user_id = ? ORDER BY created_at DESC`).all(req.user.id);
        res.json(rows);
      });
      
      app.post('/api/fields', authenticateToken, (req, res) => {
        const { name, size_acres, crop_type } = req.body;
        const result = db.prepare(`INSERT INTO fields (user_id, name, size_acres, crop_type) VALUES (?, ?, ?, ?)`).run(req.user.id, name, size_acres || 0, crop_type || '');
        res.json({ id: result.lastInsertRowid, message: 'Field created successfully' });
      });
      
      app.get('/api/plants/locations', authenticateToken, (req, res) => {
        const rows = db.prepare(`SELECT DISTINCT location_id, latitude, longitude, COUNT(*) as photo_count, MAX(timestamp) as last_visit FROM plants WHERE user_id = ? GROUP BY location_id ORDER BY last_visit DESC`).all(req.user.id);
        res.json(rows);
      });
      
      app.listen(PORT, '0.0.0.0', () => {
        console.log(`Plant Tracker API Running on port ${PORT}`);
        console.log('Demo account - username: demo, password: demo123');
      });
      EOF
    startCommand: node server.js
    envVars:
      - key: NODE_ENV
        value: production
      - key: PORT
        value: 3000